= The Little Schemer
:source-highlighter: pygments
:pygments-css: class
:sectlinks:
:toc: left
:webfonts!:
//:icons: font

== 0. Setup

I ran code and repl with Chicken Scheme, Emacs + Geiser and wrote notes in Asciidoctor.

Chicken Scheme has its own `atom?`. It returns `#t` for `'()`. The version from the book is:

=== function: `atom?'

.`atom?' function definition
[source,scheme,lineos]
----
;; Expr -> Bool
;; Takes an expression and produce #t if it is an atom; #f otherwise.
;;
;; NOTE:
;; Chicken has its own implementation of atom?. It produces
;; `#t` for '(). This version (from the book) produces #f for '().

(test-group "`atom?':"
            (test "is 'yoda an atom? Yes, it is."
                  #t
                  (atom? 'yoda))
            (test "'(foo) should not be an atom"
                  #f
                  (atom? '(foo))))

(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
----

The book's version of `atom?` returns `#f` for `'()`.

didi on #lis-br, freenode:
Heh, olha as diferenças de lisps logo no primeiro procedimento: Em CL, `'()` é um `atom', mas não para o primeiro procedimento.


== 1. Toys

These are all atoms because they are strings of characters that do not start with `(` or `)`:

foo  u  1492  *abc$

All atoms are S-expressions.

All lists are S-expressions.

=== '() is an atom?, not a pair, but still a list

`()` can be both an atom and a (null/empty) list, depending on the context. A list is a pair where there is a car field, and a cdr field, and the cdr field is a list. The empty/null list is not a pair because its length is zero and it doesn't have the car and cdr fields. The null list can be returned as the cdr of a list, though.

----
atom? '()
;; →  #t
pair? '()
;; →  #f
null? '()
;; →  #t
----

How come‽ So, `'()` is an atom, not a pair, and still, an empty list. It is those three things.

`pair?` produces `#t` if it receives a `cons`, and `'()` is *not* a cons.

`atom?` is anything that is not a `cons`.

So, `'()` is both an atom, an empty list, and although being a list, it is not a pair!

A list is a sequence of cons, and not a concrete type. A list is a pair whose ‘cdr’ is a any list (empty or non-empty).

`(cons 'x 'y) ~ '(x . y)` (`~` means “more or less like”).

[, didi at #lisp-br on freenode]
""
`(cons 'x 'y)` is created dynamically, whereas `(x . y)` is probably created during reading.
""

(eq? (cons 'x 'y) '(x . y)) => #f em Guile.
(equal? (cons 'x 'y) '(x . y)) => #t.

`eq?`, `eqv?` and `equal?` have differente semântics. Even `(eq? (cons 'x 'y) (cons 'x 'y))` produces `#f`.


(cons 'x '()) ; <1>
;; →  (x)

'(x . ()) ; <2>
;; →  (x)

(cons 'x ()) ; <3>
;; ERROR

('x . ()) ; <4>
;; ERROR

('x . '()) ; <5>
;; ERROR

'(x . '())
;; →  (x quote ()) ; <6>

1. Using `cons` and quoting each element individually.
2. Using dot notation to create a pair. Quoting the entire list instead of quoting each element individually. That is why `()` is not immediately preceded by `'`. Actually, the outer `'` quotes both `x` and `()`.
3. Consing `'x` (which is fine) into `()` (not quoted) is an error because `()` is not data, it is an empty list of code, but there is no operator/function and code to execute inside it.
4. Error because `('x ...)` is not something that can be invoked. It is seem as code, just that it is not a real operator/function invocation.
5. Same as above.
6. We are quoting `x` once, and `()` twice, therefore the output as shown.


=== The Law of car

The primitive `car` is defined only for non-empty lists.

- You cannot ask for the `car` or an atom.
- You cannot ask for the `car` of an empty list.


=== The Law of cdr

The primitive `cdr` is defined only for non-empty lists. The `cdr` of any non-empty list is always another list.

- You cannot ask for the `cdr` of an atom.
- You cannot ask for the `cdr` of an empty list.

(define l '(x y))
(car l) ; 'x, an atom.
(cdr l) ; (y), a list with one element inside it.

CDR *always always produces a list*.

Both `car` and `cdr` take non-empty lists as argument. Anything else is an error.


=== The Law of cons

[NOTE,caption=LAW]
====
The primitive `cons` takes two arguments. The second argument to `cons`
must be a list. The result is a list.

- `cons` adds an S-expression to the front of the list.
- `cons` takes an S-expression and a list as arguments.
====

=== The Law of null?

[NOTE,caption=LAW]
====
The primitive `null?` is defined only for lists.
====

In theory, you cannot ask `null?` of an atom. In practice, `null?` is `#f` for  everything, except the empty list. So, you don't get an error if you do `null? 'foo` or `null? 13`.


----
(atom? (cdr '(yoda)))
;; →  #t

(null? (cdr '(yoda)))
;; →  #t
----

`null?` is only true for empty lists. `atom?` is only true fro atoms. Yet, when `cdr` produces an empty list, that empty list is both an atom and a (null/empty) list.

NOTE: On the book, page 11, they say `(atom? (cdr '(Harry)))` is `#f` because `()` is a list. Still, some implementations consider the `()` returned by `cdr` as an atom as well.

Also, the Chicken implementation of scheme says `'()` is an atom. The one from The Little Schemer does not.

=== The Law of eq?

[NOTE,caption=LAW]
====
The primitive `eq?` takes two arguments. Each must be a non-numeric atom.
====

// TODO: verify that this is indeed true.
Note, it doesn't compare “references” in memory. `(eq? 'x 'x)` is `#t` even if they are not the same object in memory.

According to the book you can't use `eq?` on non-atom sexps, but empirical observation on a real Chicken Scheme implementation allowed it. There is a note on the book about this, actually.

In practice, `eq?` can take ints and floats as arguments, but:

[source,scheme,lineos]
----
(eq? 5 5)     ; →  #t
(eq? 5.5 5.5) ; →  #f, oops.
----

`'()` is a list of atoms because there are no lists inside it.

== 2. Do it Again and Again

=== function: `lat?'

[source,scheme,lineos]
----
;; (list-of Atom) -> Bool
;; Produce #t if l is a list of atoms, #f otherwise.

(test-group "`lat?'"
            (test "list with only atoms should be #t"
                  #t
                  (lat? '(a b c)))
            (test "list with lists inside should not be #t"
                  #f
                  (lat? '(a (b) c))))

(define lat?
  (lambda (l)
    (cond
     ((null? l) #t)
     ((atom? (car l)) (lat? (cdr l)))
     (else #f))))
----

- `(cond ...)` asks questions
- `(lambda ...)` creates a function; and
- `(define ...)` gives the function a name.

If the value of `(atom? (car l))` is `#t`, then the value of the entire function is `(lat? (cdr l))`.

`(lat? (cdr l))` asks if the rest of the list is composed only of atoms, invoking the function with a new argument.

=== function: `member?'

[source,scheme,lineos]
----
;; Atom (list-of Atom) -> Bool
;; Produce #t if the atom a exists in lat.

(test-group "`member?':"
            (test "element should be in the list of atoms"
                  #t
                  (member? 'force '(may the force be with you)))
            (test "element should not be in the list"
                  #f
                  (member? 'nix '(windows nah sorry))))

(define member?
  (lambda (a lat)
    (cond
     ((null? lat) #f)
     (else

      (or (eq? (car lat) a)
          (member? a (cdr lat)))))))
----


=== The First Commandment

[NOTE,caption=COMMANDMENT]
====
Always ask `null?` as the first question in expressing any function.
====

== 3. Cons, the Magnificent

To create `rember`, the fist thing we ask is `(null? lat)` because it is the first commandment.

=== function: `rember'

.`rember' function definition
[source,scheme,lineos]
----
;; Atom (list-of Atom) -> (list-of Atom)
;; Produce list of atoms with first occurrence of `a' removed.
;; If `a' doesn't exist in `lat', produce the unmodified list.

(test-group "`rember':"
            (test "element should be removed from beginning of lat"
                  '(y z x)
                  (rember 'x '(x y z x)))
            (test "element should be removed from middle of lat"
                  '(x z)
                  (rember 'y '(x z)))
            (test "element should be removed from end of lat"
                  '(x y)
                  (rember 'z '(x y z))))

(define rember
  (lambda (a lat)
    (cond
     ((null? lat) '())
     ((eq? (car lat) a) (cdr lat)) ; <1>
     (else
      (cons (car lat) (rember a (cdr lat))))))) ; <2>
----

1. Note that we do not recur here. This is what allows `rember` to remove only the first occurrence of `a` in `lat`.
2. Yes, here we recur to check if `a` is in the rest of `lat`.

Also note that we *do not use `cons' in this function*.

----
(rember 'x '(x y z))
;; →  (y z), looks ok.

(rember 'x '(a b c y x z))
;; →  (z), oops!
----

Since we did not use cons to keep elements that should not be removed, we lost them and got an incorrect result. We dropped `'x`, but we also lost all atoms preceding `'x`.

So, we use Cons, The Magnificent:

=== function: `rember' (correct version)

.`rember' function definition (correct this time)
[source,scheme,lineos]
----
;; Atom (list-of Atom) -> (list-of Atom)
;; Produce list of atoms with first occurrence of `a' removed.
;; If `a' doesn't exist in `lat', produce the unmodified list.
(define rember
(lambda (a lat)
(cond
 ((null? lat) '())
 (else (cond
        ((eq? (car lat) a) (cdr lat))
        ;; <1>
        (else (cons (car lat) (rember a (cdr lat)))))))))
----

1. Now we use `cons` to keep elements that should not be removed.

And we can even simplify it and use only one `cond`.

=== function: `rember' refined

.`rember`, simplified, only one `cond'
[source,scheme,lineos]
----
;; Atom (list-of Atom) -> (list-of Atom)
;; Produce list of atoms with first occurrence of `a' removed.
;; If `a' doesn't exist in `lat', produce the unmodified list.

(test-group "`rember':"
            (test "element should be removed from beginning of lat"
                  '(y z x)
                  (rember 'x '(x y z x)))
            (test "element should be removed from middle of lat"
                  '(x z)
                  (rember 'y '(x z)))
            (test "element should be removed from end of lat"
                  '(x y)
                  (rember 'z '(x y z))))

(define rember
  (lambda (a lat)
    (cond
     ((null? lat) '())
     ((eq? (car lat) a) (cdr lat))
     (else
      (cons (car lat) (rember a (cdr lat)))))))
----


=== The Second Commandment

[NOTE,caption=COMMANDMENT]
====
Use `cons` to build lists.
====

=== function: `firsts'

.`firsts' function definition
[source,scheme,lineos]
----
;; List -> List
;; Produce list with first element in each sub-list.
;; ASSUME: input list can be empty or contain only
;;         non-empty lists.
(test-group "`firsts':"
            (test "should produce '()"
                  '()
                  (firsts '()))

            (test "should get firsts"
                  '(a c y k)
                  (firsts '((a b) (c) (y z) (k t x)))))

(define firsts
  (lambda (l)
    (cond
     ((null? l) '())
     (else
      (cons (car (car l))
            (firsts (cdr l)))))))
----


=== The Third Commandment

[NOTE,caption=COMMANDMENT]
====
When building a list, describe the first tipical element, and then `cons` it into the natural recursion.
====


CONTINUE FROM PAGE 47, `insertR'.







